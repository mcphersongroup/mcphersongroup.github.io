<!-- 
This file contains the conference map and calendar for the research page.
To edit conference information:
1. Find the 'conferences' list in the first Python code block below
2. Add, remove, or modify conference entries following the existing format
3. Each conference needs: name, location, lat, lon, start_date, end_date, type, and url
4. The map and table will automatically update based on this data

This file is included in research/index.qmd and renders at the bottom of the research page.
-->

## Conference Map and Calendar

### Upcoming Conferences and Events

```{python}
#| echo: false
#| warning: false

from ipyleaflet import Map, Marker, AwesomeIcon, Popup
from ipywidgets import HTML
import datetime

# Create a map centered on North America
m = Map(center=(20, 0), zoom=2)

# Conference data - locations, dates, and details
# Sorted by start date (nearest first) and only includes upcoming conferences
conferences = [
    {
        "name": "ESCMID annual",
        "location": "Munich, Germany",
        "lat": 48.1371,
        "lon": 11.5761,
        "start_date": "2025-04-17",
        "end_date": "2025-04-21",
    "abstract_submission_window": "Nov 26 2024",
        "type": "Conference",
        "url": "https://www.escmid.org/congress-events/escmid-global/"
    },
    {
        "name": "Japan-US Research Collaboration Week",
        "location": "Stanford, CA",
        "lat": 37.4275,
        "lon": -122.1697,
        "start_date": "2025-07-28",
        "end_date": "2025-07-30",
    "abstract_submission_window": "TBD",
        "type": "Conference",
        "url": "https://jurcconference.stanford.edu/"
    },
    {
        "name": "4th United Nations Open Science and Open Scholarship Conference",
        "location": "Tokyo, Japan",
        "lat": 35.6762,
        "lon": 139.6503,
        "start_date": "2025-10-16",
        "end_date": "2025-10-18",
    "abstract_submission_window": "TBD",
        "type": "Conference",
        "url": "https://unu.edu/events"
    },
    {
        "name": "IDSA IDWeek",
        "location": "Atlanta, GA",
        "lat": 33.7490,
        "lon": -84.3880,
        "start_date": "2025-10-19",
        "end_date": "2025-10-22",
    "abstract_submission_window": "Feb 18 2025 - May 1 2025",
        "type": "Conference",
        "url": "https://www.idweek.org/"
    },
    {
        "name": "ASHP Midyear",
        "location": "New Orleans, LA",
        "lat": 29.9511,
        "lon": -90.0715,
        "start_date": "2025-12-07",
        "end_date": "2025-12-10",
    "abstract_submission_window": "Jun 15 2025 (professional) or Aug 15 2025 (trainee) - Oct 1 2025",
        "type": "Conference",
        "url": "https://www.ashp.org/meetings-and-conferences/midyear-clinical-meeting-and-exhibition"
    },
    {
        "name": "BPS Annual",
        "location": "Belfast, UK",
        "lat": 54.5973,
        "lon": -5.9301,
        "start_date": "2025-12-16",
        "end_date": "2025-12-18",
    "abstract_submission_window": "Apr 2025 - Sep 9 2025",
        "type": "Conference",
        "url": "https://www.bps.ac.uk/events"
    },
    {
        "name": "IMARI Conference",
        "location": "Las Vegas, NV",
        "lat": 36.1699,
        "lon": -115.1398,
        "start_date": "2026-01-28",
        "end_date": "2026-01-30",
    "abstract_submission_window": "Jul 16 2025 - Oct 1 2025",
        "type": "Conference",
        "url": "https://imari.org"
    },
    {
        "name": "AAAS Annual",
        "location": "Phoenix, AZ",
        "lat": 33.4484,
        "lon": -112.0740,
        "start_date": "2026-02-12",
        "end_date": "2026-02-14",
    "abstract_submission_window": "Jun 5 2025 - Sep 7 2025",
        "type": "Conference",
        "url": "https://www.aaas.org/meetings"
    },
    {
        "name": "CROI Conference",
        "location": "Denver, CO",
        "lat": 39.7392,
        "lon": -104.9903,
        "start_date": "2026-02-22",
        "end_date": "2026-02-25",
    "abstract_submission_window": "Aug 28 2025 - Oct 1 2025",
        "type": "Conference",
        "url": "https://www.croiconference.org/"
    },
    {
        "name": "ASPET Annual",
        "location": "Minneapolis, MN",
        "lat": 44.9778,
        "lon": -93.2650,
        "start_date": "2026-05-17",
        "end_date": "2026-05-20",
    "abstract_submission_window": "Sep 22 2025 - Dec 4 2025",
        "type": "Conference",
        "url": "https://www.aspet.org/aspet/meetings-awards"
    },
    {
        "name": "ISPOR 2026",
        "location": "Philadelphia, PA",
        "lat": 39.9526,
        "lon": -75.1652,
        "start_date": "2026-05-17",
        "end_date": "2026-05-20",
    "abstract_submission_window": "Oct 31 2025 - Jan 9 2026",
        "type": "Conference",
        "url": "https://www.ispor.org/conferences-education"
    },
    {
        "name": "ASM Microbe",
        "location": "Washington, DC",
        "lat": 38.9072,
        "lon": -77.0369,
        "start_date": "2026-06-11",
        "end_date": "2026-06-15",
    "abstract_submission_window": "Oct 15 2025 - Dec 2 2025 (travel); Dec 2 2025 - Jan 21 2026 (abstract)",
        "type": "Conference",
        "url": "https://asm.org/events/asm-microbe"
    },
    {
        "name": "Biennial Anaerobe",
        "location": "New York, NY, USA",
        "lat": 40.7306,
        "lon": -73.9352,
        "start_date": "2026-07-07",
        "end_date": "2026-07-10",
    "abstract_submission_window": "Oct 23 2025 - Jan 1 2026 (oral) or Feb 1, 2026 (poster)",
        "type": "Conference",
        "url": "http://www.anaerobe.org/2026/"
    },
    {
        "name": "IUPHAR 20th World Congress of Basic and Clinical Pharmacology (WCP2026)",
        "location": "Melbourne, Australia",
        "lat": -37.8136,
        "lon": 144.9631,
        "start_date": "2026-07-12",
        "end_date": "2026-07-17",
    "abstract_submission_window": "Feb - Sept 15, 2025",
        "type": "Conference",
        "url": "https://www.iuphar.org/"
    },
    {
        "name": "ASV Annual",
        "location": "Minneapolis, MN",
        "lat": 44.9778,
        "lon": -93.2650,
        "start_date": "2026-07-27",
        "end_date": "2026-07-30",
    "abstract_submission_window": "Dec 1 2025 - Feb 1 2026",
        "type": "Conference",
        "url": "https://www.asv.org/annual-meeting"
    },
    {
        "name": "Biennial MSGERC meeting",
        "location": "Denver, CO",
        "lat": 39.7392,
        "lon": -104.9903,
        "start_date": "2026-09-09",
        "end_date": "2026-09-11",
    "abstract_submission_window": "Apr - Jul 2026",
        "type": "Conference",
        "url": "https://msgerc.org/2026-biennial-meeting/"
    },
    {
        "name": "ESCV 2026 â€“ 28th Annual Conference of the European Society for Clinical Virology",
        "location": "Porto, Portugal",
        "lat": 41.1579,
        "lon": -8.6291,
        "start_date": "2026-09-16",
        "end_date": "2026-09-19",
    "abstract_submission_window": "Feb 2 - May 11 2026",
        "type": "Conference",
        "url": "https://escv.eu/calendar-events/"
    }
]

# Get current date once for all comparisons
current_date = datetime.datetime.now()

# Sort conferences by start date and parse dates once to ensure correct ordering
sorted_conferences = sorted(conferences, key=lambda x: x["start_date"])

# Parse dates once for all conferences
conf_dates = {}
for conf in sorted_conferences:
    conf_dates[conf["name"]] = {
        "start": datetime.datetime.strptime(conf["start_date"], "%Y-%m-%d"),
        "end": datetime.datetime.strptime(conf["end_date"], "%Y-%m-%d")
    }

# Find the next 3 upcoming conferences (start date in the future)
upcoming_conferences = []
for conf in sorted_conferences:
    if conf_dates[conf["name"]]["start"] > current_date:
        upcoming_conferences.append(conf["name"])
    if len(upcoming_conferences) >= 3:
        break

# Add markers for each conference location
for conf in sorted_conferences:
    # Get pre-parsed dates
    conf_start_date = conf_dates[conf["name"]]["start"]
    conf_end_date = conf_dates[conf["name"]]["end"]
    
    # Determine marker color based on conference status
    if conf_end_date < current_date:
        # Past conferences - use beige for even lighter appearance
        marker_color = 'beige'
    elif conf["name"] in upcoming_conferences:
        # Next 3 upcoming conferences - use dark red
        marker_color = 'darkred'
    else:
        # Other future conferences - use regular red
        marker_color = 'red'
    
    icon = AwesomeIcon(
        name='calendar',
        marker_color=marker_color,
        icon_color='white'
    )
    marker = Marker(
        location=(conf["lat"], conf["lon"]),
        draggable=False,
        title=conf["name"],
        icon=icon
    )
    
    # Format dates for display
    start = conf_start_date.strftime("%B %d, %Y")
    end = conf_end_date.strftime("%B %d, %Y")
    
    # Add URL link if available
    url_html = f"<br><a href='{conf['url']}' target='_blank' style='color: #007bff;'>Website</a>" if 'url' in conf else ""
    
    marker.popup = HTML(
        value=f"<div style='width: 200px;'><b>{conf['name']}</b><br><i>{conf['type']}</i><br>{conf['location']}<br>{start} - {end}{url_html}</div>"
    )
    m.add_layer(marker)

m
```

### Conference Calendar

```{python}
#| echo: false
#| warning: false

import pandas as pd
from datetime import datetime
import re

# Create a DataFrame for the conference calendar
calendar_data = []

for conf in conferences:
    start = datetime.strptime(conf["start_date"], "%Y-%m-%d")
    end = datetime.strptime(conf["end_date"], "%Y-%m-%d")
    
    calendar_data.append({
        "Event": conf["name"],
        "Type": conf["type"],
        "Location": conf["location"],
        "Abstract Submission Window": conf.get("abstract_submission_window", "TBD"),
        "Start Date": start.strftime("%B %d, %Y"),
        "End Date": end.strftime("%B %d, %Y"),
        "URL": conf.get("url", ""),
        "start_datetime": start,
        "end_datetime": end
    })

df = pd.DataFrame(calendar_data)

# Display as a styled table
from IPython.display import display, HTML

def create_calendar_html(df):
    current_date = datetime.now()

    # Helpers to detect if the current date falls within the abstract submission window
    # Support full and abbreviated month names with optional year.
    month_pattern = (
        r"Jan(?:uary)?|Feb(?:ruary)?|Mar(?:ch)?|Apr(?:il)?|May|Jun(?:e)?|Jul(?:y)?|"
        r"Aug(?:ust)?|Sep(?:t(?:ember)?)?|Oct(?:ober)?|Nov(?:ember)?|Dec(?:ember)?"
    )
    # e.g., "Oct 1, 2025" | "October 1" | "Sept. 15, 2025"
    date_regex = re.compile(rf"\b({month_pattern})\.?\s+(\d{{1,2}})(?:,\s*(\d{{4}}))?\b", re.IGNORECASE)

    def _normalize_year(month_idx, day, year_str, conf_start_dt):
        """Infer year if omitted: default to conference start year."""
        if year_str:
            return int(year_str)
        return conf_start_dt.year

    def _month_to_index(mon):
        mon = mon.strip('.').lower()
        lookup = {
            'jan': 1, 'january': 1,
            'feb': 2, 'february': 2,
            'mar': 3, 'march': 3,
            'apr': 4, 'april': 4,
            'may': 5,
            'jun': 6, 'june': 6,
            'jul': 7, 'july': 7,
            'aug': 8, 'august': 8,
            'sep': 9, 'sept': 9, 'september': 9,
            'oct': 10, 'october': 10,
            'nov': 11, 'november': 11,
            'dec': 12, 'december': 12,
        }
        return lookup.get(mon, 1)

    def extract_dates_with_context(text, conf_start_dt):
        if not text:
            return []
        dates = []
        for m in date_regex.finditer(text):
            mon, day_str, year_str = m.group(1), m.group(2), m.group(3)
            month_idx = _month_to_index(mon)
            day = int(day_str)
            year = _normalize_year(month_idx, day, year_str, conf_start_dt)
            try:
                dates.append(datetime(year, month_idx, day))
            except ValueError:
                # Skip invalid dates if any
                continue
        return dates

    def parse_window_bounds(window_text, conf_start_dt):
        """Return (start, end) bounds if determinable from text; else (None, None)."""
        if not window_text:
            return (None, None)
        t = window_text.strip()
        if not t or t.upper() == 'TBD':
            return (None, None)
        # Remove parenthetical notes for easier parsing (keep dates elsewhere)
        t_noparen = re.sub(r"\([^\)]*\)", "", t)
        lower = t_noparen.lower()

        # Opens X  => [X, conf_start]
        if lower.startswith('opens '):
            dates = extract_dates_with_context(t_noparen, conf_start_dt)
            if not dates:
                return (None, None)
            return (dates[0], conf_start_dt)

        # Through X => [-inf, X]
        if lower.startswith('through '):
            dates = extract_dates_with_context(t_noparen, conf_start_dt)
            if not dates:
                return (None, None)
            return (None, dates[0])

        # General ranges possibly with multiple starts/ends separated by 'or'
        if ' to ' in lower:
            left, right = t_noparen.split(' to ', 1)
            left_dates = extract_dates_with_context(left, conf_start_dt)
            right_dates = extract_dates_with_context(right, conf_start_dt)
            start = min(left_dates) if left_dates else None
            end = max(right_dates) if right_dates else None
            # If only one side provided, use conference start as fallback end
            if start and not end:
                end = conf_start_dt
            # If both present but end < start, assume end is in next year
            if start and end and end < start:
                try:
                    end = end.replace(year=end.year + 1)
                except ValueError:
                    pass
            return (start, end)

        # Otherwise, treat any dates found as a deadline window [min, max]
        dates = extract_dates_with_context(t_noparen, conf_start_dt)
        if not dates:
            return (None, None)
        if len(dates) == 1:
            # Single date: open until that date
            return (None, dates[0])
        return (min(dates), max(dates))

    def is_window_active(window_text, conf_start_dt):
        start, end = parse_window_bounds(window_text, conf_start_dt)
        if start and end:
            return start <= current_date <= end
        if start and not end:
            return start <= current_date <= conf_start_dt
        if end and not start:
            return current_date <= end
        return False
    
    # Find the next upcoming conference (first one with start date in the future)
    next_upcoming_idx = None
    for idx, row in df.iterrows():
        if row['start_datetime'] > current_date:
            next_upcoming_idx = idx
            break
    
    html = """
    <style>
        .calendar-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        .calendar-table thead tr {
            background-color: #007bff;
            color: white;
            text-align: left;
            font-weight: bold;
        }
        .calendar-table th,
        .calendar-table td {
            padding: 12px 15px;
            border: 1px solid #ddd;
        }
        .calendar-table tbody tr {
            border-bottom: 1px solid #dddddd;
        }
        .calendar-table tbody tr:nth-of-type(even) {
            background-color: #f3f3f3;
        }
        .calendar-table tbody tr:hover {
            background-color: #e3f2fd;
            cursor: pointer;
        }
        .calendar-table tbody tr.past-conference {
            opacity: 0.5;
            background-color: #f9f9f9;
            color: #999;
        }
        .calendar-table tbody tr.past-conference:nth-of-type(even) {
            background-color: #f5f5f5;
        }
        .calendar-table tbody tr.next-upcoming {
            font-weight: bold;
            background-color: #fff3cd;
            border: 2px solid #ffc107;
        }
        .calendar-table tbody tr.next-upcoming:hover {
            background-color: #ffe69c;
        }
        .event-type {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: bold;
        }
        .type-conference {
            background-color: #4CAF50;
            color: white;
        }
        .type-summit {
            background-color: #FF9800;
            color: white;
        }
        .type-symposium {
            background-color: #2196F3;
            color: white;
        }
        .type-workshop {
            background-color: #9C27B0;
            color: white;
        }
        /* Highlight style for currently open submission windows */
        .submission-window.active {
            color: #d32f2f;
            font-weight: 600;
        }
    </style>
    <table class="calendar-table">
        <thead>
            <tr>
                <th>Event Name</th>
                <th>Type</th>
                <th>Location</th>
                <th>Abstract Submission Window</th>
                <th>Start Date</th>
                <th>End Date</th>
                <th>Website</th>
            </tr>
        </thead>
        <tbody>
    """
    
    for idx, row in df.iterrows():
        type_class = f"type-{row['Type'].lower()}"
        url_link = f"<a href='{row['URL']}' target='_blank' style='color: #007bff;'>Visit</a>" if row['URL'] else "N/A"
        
        # Determine row classes
        row_classes = []
        if row['end_datetime'] < current_date:
            row_classes.append("past-conference")
        if idx == next_upcoming_idx:
            row_classes.append("next-upcoming")
        
        row_class_str = f" class='{' '.join(row_classes)}'" if row_classes else ""
        
        # Build window cell with data attributes so the browser can determine 'active' based on its current date
        window_text = row['Abstract Submission Window']
        start_bound, end_bound = parse_window_bounds(window_text, row['start_datetime'])
        start_iso = start_bound.strftime('%Y-%m-%d') if start_bound else ''
        end_iso = end_bound.strftime('%Y-%m-%d') if end_bound else ''
        conf_start_iso = row['start_datetime'].strftime('%Y-%m-%d')
        window_cell = (
            f"<span class='submission-window' data-start='{start_iso}' data-end='{end_iso}' data-conf-start='{conf_start_iso}'>{window_text}</span>"
        )

        html += f"""
            <tr{row_class_str}>
                <td><strong>{row['Event']}</strong></td>
                <td><span class="event-type {type_class}">{row['Type']}</span></td>
                <td>{row['Location']}</td>
                <td>{window_cell}</td>
                <td>{row['Start Date']}</td>
                <td>{row['End Date']}</td>
                <td>{url_link}</td>
            </tr>
        """
    
        # Add a small script to toggle 'active' class for windows based on the viewer's current date
        html += """
        </tbody>
    </table>
        <script>
        (function(){
            function parseISO(d){ return d ? new Date(d + 'T00:00:00') : null; }
            const now = new Date(); now.setHours(0,0,0,0);
            document.querySelectorAll('.submission-window').forEach(function(el){
                const s = parseISO(el.dataset.start);
                const e = parseISO(el.dataset.end);
                const cs = parseISO(el.dataset.confStart);
                let active = false;
                if (s && e) {
                    active = (s <= now && now <= e);
                } else if (s && !e) {
                    active = (cs ? (s <= now && now <= cs) : (s <= now));
                } else if (!s && e) {
                    active = (now <= e);
                }
                if (active) el.classList.add('active');
            });
        })();
        </script>
    """
    return html

display(HTML(create_calendar_html(df)))
```
